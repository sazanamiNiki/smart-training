## 課題：フラットなパスからのファイルシステム復元（エラー収集モード） 🌳

### 概要
ファイルパスのリストを受け取り、ツリー構造に変換します。ファイル名とディレクトリ名の衝突などの矛盾が発生した場合は、処理を中断せず、エラーリストに記録して次のパスの処理へ進んでください。

### あなたのミッション
提供される `main` 関数を完成させ、引数 `paths` を解析し、ツリー構造とエラーリストを含むオブジェクトを返してください。

---
### ルールと仕様

1.  **階層構造**:
    * パスは `/` で区切られています。
2.  **ファイルとディレクトリの識別**:
    * パスの**最後の要素**にドット `.` がある → **ファイル**
    * パスの**最後の要素**にドット `.` がない → **ディレクトリ**
    * **途中**の要素 → 常に**ディレクトリ**
3.  **出力データの構造**:
    * **サブディレクトリ**: ディレクトリ名をキー、子要素を値とするオブジェクト。
    * **ファイル**: ディレクトリ内の **`files`** 配列に格納。
4.  **【変更】整合性チェックとエラーハンドリング**:
    * 同じ親ディレクトリ配下での「ファイル名」と「ディレクトリ名」の衝突を検知してください。
    * 矛盾が発生した場合：
        1.  そのパスの処理は**そこで中断**します（既存の構造を破壊しないため）。
        2.  エラー内容（メッセージ文字列）を **`errors` 配列**に追加します。
        3.  例外（throw）は投げず、次のパスの処理に進みます。

### 入出力の仕様

* **入力**: `paths: string[]`
* **出力**: `{ tree: Record<string, any>, errors: string[] }`
    * `tree`: 構築されたファイルシステム構造。
    * `errors`: 発生したエラーメッセージの配列。

---
### 実装例

```javascript
const paths = [
  // 正常系: 複雑な構造
  "/home/user/docs/report.pdf", // 深い階層のファイル
  "/home/user/photos",          // ディレクトリ
  "/home/user/memo.txt",        // 同じ /home/user 直下のファイル
  "/var/log/app/error.log",     // 3階層以上のネスト
  "/var/log/syslog",            // 別のサブディレクトリ配下 (syslogはドットがないのでディレクトリ扱い)

  // 異常系: 衝突
  "/etc/app.conf",              // 末尾にドットあり -> 「ファイル」として登録
  "/etc/app.conf/settings"      // エラー: app.conf はファイルなのに、ディレクトリとして掘り下げようとしている
];

const result = main(paths);

// 期待される出力結果
/*
{
  tree: {
    home: {
      user: {
        docs: {
          files: ["report.pdf"]
        },
        photos: {},
        files: ["memo.txt"]
      }
    },
    var: {
      log: {
        app: {
          files: ["error.log"]
        },
        syslog: {} // syslogはディレクトリ
      }
    },
    etc: {
      files: ["app.conf"]
    }
  },
  errors: [
    "Invalid path: /etc/app.conf/settings (Conflict with existing file)"
  ]
}
*/
